%{
#include <linux/security.h>
#include <linux/namei.h>
#include <linux/xattr.h>
#define SECCLASS_PROCESS   2
%}

function context_str_to_sid:long (context:string){
	#TBD nontrival, no standard interface is provided
}
function sid_to_context_str:string (sid:long)%{
	/*return the pointer to */
	char * ret;
	int len;
	security_secid_to_secctx( STAP_ARG_sid, &ret, &len);
	snprintf(STAP_RETVALUE, MAXSTRINGLEN, "%s", ret);
	kfree(ret);
%}

function task2sid:long (t:long) %{ /*pure*/
	u32 ret;
	security_task_getsecid((struct task_struct *)(long) STAP_ARG_t, &ret);
	STAP_RETVALUE = (long) ret;
%}

function pid2sid:long (pid:long) {
	return task2sid(pid2task(pid))
}

function pid2sstr:string (pid:long) {
	return sid_to_context_str(pid2sid(pid));
}

function filectx:string (path:string) %{
	struct path path;
	int ret;
	u32 sid, ctxlen;
	struct inode *inode;
	char * ctx;
	unsigned int lookup_flags = 0;
	ret = kern_path(STAP_ARG_path, lookup_flags, &path);	
	if (!ret){
		inode = path.dentry->d_inode;
		security_inode_getsecctx(inode,(void **) &ctx, &ctxlen);
		snprintf(STAP_RETVALUE, ctxlen, "%s", ctx);
		kfree(ctx);
	}
%}
